when RULE_INIT {
    # enable (1) / disable (0) logging
    set static::contentswitching_debug 1
}
 
when HTTP_REQUEST {
    # optimale Security (SSLF)
    if { [HTTP::host] contains "\["  } {
        if { $static::contentswitching_debug } { log local0. "Drop: square bracket in HTTP host header." }
        drop
        return
    }

    # Matching HTTP::host and HTTP::path to pool
    if { [catch { pool [class match -value [string tolower [HTTP::host][HTTP::path]] starts_with dg_applications] }]} {
        if { $static::contentswitching_debug } { log local0. "Caught exception: no pool matching for [string tolower [HTTP::host][HTTP::path]] ...retrying." }
        return
    }
    if { $static::contentswitching_debug } { log local0. "Using pool: [LB::server pool]" }
    
    # Set STREAM expression for HTTP_RESPONE context
    if { $static::contentswitching_debug } { log local0. "Matching URL for STREAM: [class match -name [string tolower [HTTP::path]] starts_with dg_link_rewrite ]" }
    if { [catch { set substitute [class match -value [string tolower [HTTP::path]] starts_with dg_link_rewrite ] } err ] } {
        return
    }

  # Rewrite HTTP::host and HTTP::path
    set Url [HTTP::host][HTTP::path]
    set Url [regsub -nocase [class match -name $Url contains dg_URL_rewrite] $Url [class match -value $Url contains dg_URL_rewrite] ]
    HTTP::host [getfield $Url "/" 1]
    HTTP::path [regsub -nocase [HTTP::host] $Url "" ]
    unset Url
    if { $static::contentswitching_debug } { log local0. "New HTTP host is: [HTTP::host]" }
    if { $static::contentswitching_debug } { log local0. "New HTTP path is: [HTTP::path]" }

    # Explicitly disable the stream profile for each client-side request so it doesn't stay
    # enabled for subsequent HTTP requests on the same TCP connection.
    STREAM::disable
    # LTM does not uncompress response content, so if the webserver has compression enabled
    # we must prevent the server from send us a compressed response by changing the request
    # header that indicates client support for compression (on our LTM client-side we can re-
    # apply compression before the response goes across the Internet)
    HTTP::header remove "Accept-Encoding"
}

when HTTP_RESPONSE {
    # Rewrite Location response header
    # matches ONLY the first occurance of the expression
    if { [HTTP::header exists Location] }{
        if { $static::contentswitching_debug } { log local0. "Matching HTTP Location header. New value: [class match -value [string tolower [HTTP::header Location]] starts_with dg_return_path-rewrite]" }
        HTTP::header replace Location [regsub -nocase [class match -name [string tolower [HTTP::header Location]] starts_with dg_return_path-rewrite] [HTTP::header Location] [class match -value [string tolower [HTTP::header Location]] starts_with dg_return_path-rewrite] ]
    }

    # Explicitly disable the stream profile for each server-side response so it doesn't stay
    # enabled for subsequent HTTP responses on the same TCP connection.
    STREAM::disable
    
    # Substitute internal hyperlinks in response body
    if { [ catch { if { [info exists substitute] } {
        # Apply stream profile against text responses from the application
        if {[HTTP::header value Content-Type] starts_with "text"} {
            if { $static::contentswitching_debug } { log local0. "STREAM expression for substitution: $substitute" }
            STREAM::expression [string trim $substitute " "]
            STREAM::enable
        }
    } } ] } {
        if { $static::contentswitching_debug } { log local0. "Problem substituting string: $substitute" }
        return
    }
}