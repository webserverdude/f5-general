when RULE_INIT {
    # enable (1) / disable (0) logging
    set static::contentswitching_debug 1
}
 
when HTTP_REQUEST {
    # Matching HTTP::host and HTTP::path to pool
    if { [catch { pool [class match -value [string tolower [HTTP::host][HTTP::path]] starts_with dg_applications] }]} {
        if { $static::contentswitching_debug } { log local0. "Caught exception: no pool matching for [string tolower [HTTP::host][HTTP::path]] ...retrying." }
        return
    }
    if { $static::contentswitching_debug } { log local0. "Using pool: [LB::server pool]" }
    
    # Set STREAM expression for HTTP_RESPONE context
    if { $static::contentswitching_debug } { log local0. "Matching URL for STREAM: [class match -name [string tolower [HTTP::path]] starts_with dg_link_rewrite ]" }
    if { [catch { set substitute [class match -value [string tolower [HTTP::path]] starts_with dg_link_rewrite ] } err ] } {
        return
    }
    
    # Rewrite Host request header
    if { $static::contentswitching_debug } { log local0. "Matching Internal Host. New value: [class match -value [string tolower [HTTP::path]] starts_with dg_hostheader]" }
    if { [class match [string tolower [HTTP::path]] starts_with dg_hostheader] } {
        if { [catch {HTTP::header replace host [class match -value [string tolower [HTTP::path]] starts_with dg_hostheader] } err ] } {
            if { $static::contentswitching_debug } { log local0. "Path rewrite error message: $err" }
            return
        }
    }

  # Rewrite HTTP::path
    if { [class match [string tolower [HTTP::path]] starts_with dg_path-rewrite] } {
        if { $static::contentswitching_debug } { log local0. "Matching HTTP:path for rewrite. New value: [class match -value [string tolower [HTTP::path]] starts_with dg_path-rewrite]" }
        # Path rewrite based on HTTP::path
        if { [catch { HTTP::path [regsub -nocase [class match -name [string tolower [HTTP::path]] starts_with dg_path-rewrite] [HTTP::path] [class match -value [string tolower [HTTP::path]] starts_with dg_path-rewrite] ] } ] } {
            if { $static::contentswitching_debug } { log local0. "Caught exception: Error rewriting [HTTP::path]" }
            return
            }
    } elseif { [class match $hostheader starts_with dg_path-rewrite] } {
        if { $static::contentswitching_debug } { log local0. "Matching HTTP:path for rewrite. New value: [class match -value $hostheader starts_with dg_path-rewrite]" }
        # Path rewrite based on HTTP::host
        if { [catch { HTTP::path [regsub -nocase [class match -name $hostheader starts_with dg_path-rewrite] $hostheader [class match -value $hostheader starts_with dg_path-rewrite] ] } ] } {
            if { $static::contentswitching_debug } { log local0. "Caught exception: Error rewriting [HTTP::path]" }
            return
        }
    } else {
        return  
    }
    if { $static::contentswitching_debug } { log local0. "New HTTP path is: [HTTP::path]" }

    # Explicitly disable the stream profile for each client-side request so it doesn't stay
    # enabled for subsequent HTTP requests on the same TCP connection.
    STREAM::disable
    # LTM does not uncompress response content, so if the webserver has compression enabled
    # we must prevent the server from send us a compressed response by changing the request
    # header that indicates client support for compression (on our LTM client-side we can re-
    # apply compression before the response goes across the Internet)
    HTTP::header remove "Accept-Encoding"
}

when HTTP_RESPONSE {
    # Rewrite Location response header
    if { [HTTP::header exists Location] }{
        if { $static::contentswitching_debug } { log local0. "Matching HTTP Location header. New value: [class match -value [string tolower [HTTP::header Location]] starts_with dg_return_path-rewrite]" }
        HTTP::header replace Location [regsub -nocase [class match -name [string tolower [HTTP::header Location]] starts_with dg_return_path-rewrite] [HTTP::header Location] [class match -value [string tolower [HTTP::header Location]] starts_with dg_return_path-rewrite] ]
    }

    # Explicitly disable the stream profile for each server-side response so it doesn't stay
    # enabled for subsequent HTTP responses on the same TCP connection.
    STREAM::disable
    
    # Substitute internal hyperlinks in response body
    if {$substitute ne ""} {
        # Apply stream profile against text responses from the application
        if {[HTTP::header value Content-Type] starts_with "text"} {
            if { $static::contentswitching_debug } { log local0. "STREAM expression for substitution: $substitute" }
            STREAM::expression [string trim $substitute " "]
            STREAM::enable
        }
    }
}